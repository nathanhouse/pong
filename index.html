<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Laser Pong: Zombie Vampires</title>
  <style>
    body { 
      margin: 0; 
      background: black; 
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { 
      display: block; 
      background: black;
      max-width: 100%;
      max-height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// Declare global variables
let WINDOW_WIDTH, WINDOW_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, BALL_SIZE, PADDLE_SPEED, BALL_SPEED, BORDER_WIDTH, SHIELD_RADIUS;
let ctx; // Declare ctx as a global variable

// Constants
const ASPECT_RATIO = 4 / 3; // Maintain a 4:3 aspect ratio

// Function to resize the canvas
function resizeCanvas() {
  const canvas = document.getElementById("gameCanvas");
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  if (width / height > ASPECT_RATIO) {
    canvas.height = height;
    canvas.width = height * ASPECT_RATIO;
  } else {
    canvas.width = width;
    canvas.height = width / ASPECT_RATIO;
  }
  
  // Update global constants based on new canvas size
  WINDOW_WIDTH = canvas.width;
  WINDOW_HEIGHT = canvas.height;
  PADDLE_WIDTH = WINDOW_WIDTH * 0.02;
  PADDLE_HEIGHT = WINDOW_HEIGHT * 0.15;
  BALL_SIZE = WINDOW_WIDTH * 0.05;
  PADDLE_SPEED = WINDOW_HEIGHT * 0.02;
  BALL_SPEED = WINDOW_WIDTH * 0.005;
  BORDER_WIDTH = WINDOW_WIDTH * 0.005;
  SHIELD_RADIUS = WINDOW_WIDTH * 0.05;
  
  ctx = canvas.getContext("2d");
}

// Call resizeCanvas initially to set up the canvas size
resizeCanvas();

// Function to handle window resize with debouncing
let resizeTimeout;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(function() {
    resizeCanvas();
    if (game) {
      // Adjust paddle and ball positions after resize
      game.leftPaddle.x = 50;
      game.rightPaddle.x = WINDOW_WIDTH - 50 - PADDLE_WIDTH;
      game.ball.reset();
    }
  }, 100);
});

// Player-specific constants
const PLAYER_LASER_SPEED = 12;
const PLAYER_LASER_COOLDOWN = 300;
const PLAYER_SHIELD_DURATION = 2000;

// AI-specific constants
const AI_LASER_SPEEDS = {1: 8, 2: 10, 3: 13}; // Speeds for Easy, Medium, Hard
const AI_LASER_COOLDOWNS = {1: 600, 2: 400, 3: 100};
const AI_SHIELD_DURATIONS = {1: 1000, 2: 1500, 3: 2000}; // Shield duration by difficulty

// Laser dimensions
const LASER_WIDTH = 20;
const LASER_HEIGHT = 5;

// Game duration in milliseconds
const GAME_DURATION = 60000;

// Scoring values
const SCORE_BAT_BOUNCE = 2;
const SCORE_LASER_PADDLE = 3;
const SCORE_BALL_PAST = 5;
const SCORE_LASER_BALL = 1;

let VERSION = "0.7.15";
document.title = `Laser Pong: Zombie Vampires v.${VERSION}`;

// AI speeds by difficulty: 1 - Easy, 2 - Medium, 3 - Hard
const AI_SPEEDS = {1: 3, 2: 6, 3: 15};

// Global variable for selected AI level in one-player mode
let selectedAiLevel = 2;

// Audio Setup
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(frequency, duration) {
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  oscillator.start(audioCtx.currentTime);
  oscillator.stop(audioCtx.currentTime + duration);
}
function playLaserSound() { playTone(880, 0.1); }
function playBounceSound() { playTone(440, 0.1); }
function playHitSound() { playTone(200, 0.1); }

// Game Classes
class Laser {
  constructor(x, y, direction, isAI = false) {
    this.x = x;
    this.y = y;
    this.width = LASER_WIDTH;
    this.height = LASER_HEIGHT;
    this.direction = direction; // 1: right, -1: left
    this.speed = (isAI ? AI_LASER_SPEEDS[game.aiLevel] : PLAYER_LASER_SPEED) * direction;
  }
  move() { this.x += this.speed; }
  draw() {
    ctx.fillStyle = "yellow";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Paddle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.width = PADDLE_WIDTH;
    this.height = PADDLE_HEIGHT;
    this.score = 0;
    this.color = color;
    this.shieldsRemaining = 5;
    this.shieldActive = false;
    this.shieldStartTime = 0;
  }
  move(up) {
    if (up && this.y > BORDER_WIDTH) this.y -= PADDLE_SPEED;
    if (!up && this.y + this.height < WINDOW_HEIGHT - BORDER_WIDTH) this.y += PADDLE_SPEED;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    if (this.shieldActive) {
      ctx.beginPath();
      ctx.arc(this.x + this.width/2, this.y + this.height/2, SHIELD_RADIUS, 0, Math.PI * 2);
      ctx.strokeStyle = "lime";
      ctx.stroke();
    }
  }
  activateShield() {
    if (this.shieldsRemaining > 0 && !this.shieldActive) {
      this.shieldsRemaining--;
      this.shieldActive = true;
      this.shieldStartTime = Date.now();
    }
  }
}

class Ball {
  constructor() {
    this.explode = false;
    this.reset();
  }
  reset() {
    this.x = WINDOW_WIDTH/2 - BALL_SIZE/2;
    this.y = WINDOW_HEIGHT/2 - BALL_SIZE/2;
    this.size = BALL_SIZE;
    this.explode = false;
    this.speedX = BALL_SPEED * (Math.random() < 0.5 ? -1 : 1);
    this.speedY = BALL_SPEED * (Math.random() < 0.5 ? -1 : 1);
  }
  move() {
    if (!this.explode) {
      this.x += this.speedX;
      this.y += this.speedY;
      if (this.y <= BORDER_WIDTH || this.y + this.size >= WINDOW_HEIGHT - BORDER_WIDTH) {
        this.speedY *= -1;
        playBounceSound();
      }
    }
  }
  draw() {
    if (this.explode) {
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI*2);
      ctx.fill();
      let eyeRadius = this.size/6;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(this.x + this.size/2 - this.size/4, this.y + this.size/2 - this.size/8, eyeRadius, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x + this.size/2 + this.size/4, this.y + this.size/2 - this.size/8, eyeRadius, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

// Helper Functions
function drawBorder() {
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, WINDOW_WIDTH, BORDER_WIDTH);
  ctx.fillRect(0, WINDOW_HEIGHT - BORDER_WIDTH, WINDOW_WIDTH, BORDER_WIDTH);
}

// Game State Variables
let game;
let currentScreen = "splash";
let onePlayerMode = false;

// Splash Screen
function showSplashScreen() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

  // Dynamic font sizes based on canvas size
  const titleFontSize = Math.min(WINDOW_WIDTH * 0.05, 50); // Max 50px
  const textFontSize = Math.min(WINDOW_WIDTH * 0.02, 24);  // Max 24px

  ctx.fillStyle = "white";
  ctx.font = `${titleFontSize}px sans-serif`;
  let title = `Laser Pong: Zombie Vampires v.${VERSION}`;
  ctx.fillText(title, (WINDOW_WIDTH - ctx.measureText(title).width) / 2, titleFontSize + 20);

  ctx.font = `${textFontSize}px sans-serif`;
  let instructions = [
    "Controls:",
    "Red Paddle (Player 1 - Left): W (up), S (down), A (shoot laser), Z (shield)",
    "Blue Paddle (Player 2 - Right): Up (up), Down (down), Left (shoot laser), Right (shield)",
    "In One Player mode, you'll face an AI.",
    "",
    "Scoring:",
    " • Bounce ball off your paddle: +2 points",
    " • Laser hitting opponent's paddle: +3 points",
    " • Laser hitting the ball: +1 point (ball explodes and resets)",
    " • Ball passing the opponent: +5 points",
    "",
    "Game lasts 60 seconds. Highest score wins!",
    "",
    "Press any key to continue..."
  ];

  let startY = titleFontSize + 40;
  instructions.forEach(line => {
    ctx.fillText(line, (WINDOW_WIDTH - ctx.measureText(line).width) / 2, startY);
    startY += textFontSize + 5; // Add some spacing between lines
  });
}

// Mode Selection Screen
function showModeSelect() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  ctx.fillStyle = "white";
  ctx.font = "40px sans-serif";
  let text = "Select Game Mode";
  ctx.fillText(text, (WINDOW_WIDTH - ctx.measureText(text).width)/2, 200);
  
  ctx.font = "30px sans-serif";
  let option1 = "1 - One Player (vs AI)";
  let option2 = "2 - Two Player";
  ctx.fillText(option1, (WINDOW_WIDTH - ctx.measureText(option1).width)/2, 300);
  ctx.fillText(option2, (WINDOW_WIDTH - ctx.measureText(option2).width)/2, 350);
  ctx.font = "24px sans-serif";
  let promptText = "Press 1 or 2 to select";
  ctx.fillText(promptText, (WINDOW_WIDTH - ctx.measureText(promptText).width)/2, 420);
}

// Difficulty Selection Screen (One Player)
function showDifficultySelect() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  ctx.fillStyle = "white";
  ctx.font = "40px sans-serif";
  let text = "Select AI Difficulty";
  ctx.fillText(text, (WINDOW_WIDTH - ctx.measureText(text).width)/2, 200);
  
  ctx.font = "30px sans-serif";
  let easy = "1 - Easy";
  let medium = "2 - Medium";
  let hard = "3 - Hard";
  ctx.fillText(easy, (WINDOW_WIDTH - ctx.measureText(easy).width)/2, 300);
  ctx.fillText(medium, (WINDOW_WIDTH - ctx.measureText(medium).width)/2, 350);
  ctx.fillText(hard, (WINDOW_WIDTH - ctx.measureText(hard).width)/2, 400);
  ctx.font = "24px sans-serif";
  let promptText = "Press 1, 2, or 3 to select";
  ctx.fillText(promptText, (WINDOW_WIDTH - ctx.measureText(promptText).width)/2, 480);
}

// Color Selection Screen (One Player)
function showColorSelect() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  ctx.fillStyle = "white";
  ctx.font = "40px sans-serif";
  let text = "Select Your Color";
  ctx.fillText(text, (WINDOW_WIDTH - ctx.measureText(text).width)/2, 200);
  
  ctx.font = "30px sans-serif";
  let redOption = "1 - Red (Left)";
  let blueOption = "2 - Blue (Right)";
  ctx.fillText(redOption, (WINDOW_WIDTH - ctx.measureText(redOption).width)/2, 300);
  ctx.fillText(blueOption, (WINDOW_WIDTH - ctx.measureText(blueOption).width)/2, 350);
  ctx.font = "24px sans-serif";
  let promptText = "Press 1 or 2 to select";
  ctx.fillText(promptText, (WINDOW_WIDTH - ctx.measureText(promptText).width)/2, 420);
}

// Start Game Session
function startGame(aiLevel = 2, humanPlayer = null) {
  game = {
    onePlayer: onePlayerMode,
    aiLevel: aiLevel,
    humanPlayer: humanPlayer, // "red" or "blue" for one-player; null for two-player
    leftPaddle: new Paddle(50, WINDOW_HEIGHT/2 - PADDLE_HEIGHT/2, "red"),
    rightPaddle: new Paddle(WINDOW_WIDTH - 50 - PADDLE_WIDTH, WINDOW_HEIGHT/2 - PADDLE_HEIGHT/2, "blue"),
    ball: new Ball(),
    lasers: [],
    lastLeftShot: 0,
    lastRightShot: 0,
    startTime: Date.now(),
    gameOver: false
  };
}

// AI for Right Paddle (human as red)
function updateAIPaddle() {
  let aiSpeed = AI_SPEEDS[game.aiLevel] || AI_SPEEDS[2];
  let targetY = game.ball.y + game.ball.size/2 - game.rightPaddle.height/2;
  if (game.rightPaddle.y < targetY) {
    game.rightPaddle.y += aiSpeed;
  } else if (game.rightPaddle.y > targetY) {
    game.rightPaddle.y -= aiSpeed;
  }
  if (game.rightPaddle.y < BORDER_WIDTH) game.rightPaddle.y = BORDER_WIDTH;
  if (game.rightPaddle.y + game.rightPaddle.height > WINDOW_HEIGHT - BORDER_WIDTH)
    game.rightPaddle.y = WINDOW_HEIGHT - BORDER_WIDTH - game.rightPaddle.height;

  // Shield activation for incoming lasers (from left)
  if (!game.rightPaddle.shieldActive && game.rightPaddle.shieldsRemaining > 0) {
    for (let laser of game.lasers) {
      if (laser.direction > 0 && laser.x < game.rightPaddle.x && laser.x > game.rightPaddle.x - 100 &&
          laser.y > game.rightPaddle.y && laser.y < game.rightPaddle.y + game.rightPaddle.height) {
        game.rightPaddle.activateShield();
        break;
      }
    }
  }

  // Use all shields before game ends
  let currentTime = Date.now();
  let timeLeft = GAME_DURATION - (currentTime - game.startTime);
  let totalShieldTime = AI_SHIELD_DURATIONS[game.aiLevel] * game.rightPaddle.shieldsRemaining;
  if (timeLeft < totalShieldTime && !game.rightPaddle.shieldActive && game.rightPaddle.shieldsRemaining > 0) {
    game.rightPaddle.activateShield();
  }
}

// AI for Left Paddle (human as blue)
function updateAIPaddleLeft() {
  let aiSpeed = AI_SPEEDS[game.aiLevel] || AI_SPEEDS[2];
  let targetY = game.ball.y + game.ball.size/2 - game.leftPaddle.height/2;
  if (game.leftPaddle.y < targetY) {
    game.leftPaddle.y += aiSpeed;
  } else if (game.leftPaddle.y > targetY) {
    game.leftPaddle.y -= aiSpeed;
  }
  if (game.leftPaddle.y < BORDER_WIDTH) game.leftPaddle.y = BORDER_WIDTH;
  if (game.leftPaddle.y + game.leftPaddle.height > WINDOW_HEIGHT - BORDER_WIDTH)
    game.leftPaddle.y = WINDOW_HEIGHT - BORDER_WIDTH - game.leftPaddle.height;

  // Shield activation for incoming lasers (from right)
  if (!game.leftPaddle.shieldActive && game.leftPaddle.shieldsRemaining > 0) {
    for (let laser of game.lasers) {
      if (laser.direction < 0 && laser.x > game.leftPaddle.x + game.leftPaddle.width && laser.x < game.leftPaddle.x + game.leftPaddle.width + 100 &&
          laser.y > game.leftPaddle.y && laser.y < game.leftPaddle.y + game.leftPaddle.height) {
        game.leftPaddle.activateShield();
        break;
      }
    }
  }

  // Use all shields before game ends
  let currentTime = Date.now();
  let timeLeft = GAME_DURATION - (currentTime - game.startTime);
  let totalShieldTime = AI_SHIELD_DURATIONS[game.aiLevel] * game.leftPaddle.shieldsRemaining;
  if (timeLeft < totalShieldTime && !game.leftPaddle.shieldActive && game.leftPaddle.shieldsRemaining > 0) {
    game.leftPaddle.activateShield();
  }
}

// Main Game Update
function updateGame() {
  let currentTime = Date.now();
  if (currentTime - game.startTime >= GAME_DURATION) {
    game.gameOver = true;
  }
  
  // One-Player Mode Controls
  if (game.onePlayer) {
    if (game.humanPlayer === "red") {
      if (keysPressed["w"]) game.leftPaddle.move(true);
      if (keysPressed["s"]) game.leftPaddle.move(false);
      if (keysPressed["z"]) game.leftPaddle.activateShield();
      if (keysPressed["a"] && currentTime - game.lastLeftShot >= PLAYER_LASER_COOLDOWN) {
        game.lasers.push(new Laser(game.leftPaddle.x + game.leftPaddle.width, game.leftPaddle.y + game.leftPaddle.height/2, 1));
        playLaserSound();
        game.lastLeftShot = currentTime;
      }
      updateAIPaddle();
      if (currentTime - game.lastRightShot >= AI_LASER_COOLDOWNS[game.aiLevel]) {
        if (game.ball.speedX > 0 && game.ball.x > WINDOW_WIDTH/2) {
          game.lasers.push(new Laser(game.rightPaddle.x, game.ball.y + game.ball.size/2, -1, true));
          playLaserSound();
          game.lastRightShot = currentTime;
        }
      }
    } else if (game.humanPlayer === "blue") {
      if (keysPressed["ArrowUp"]) game.rightPaddle.move(true);
      if (keysPressed["ArrowDown"]) game.rightPaddle.move(false);
      if (keysPressed["ArrowRight"]) game.rightPaddle.activateShield();
      if (keysPressed["ArrowLeft"] && currentTime - game.lastRightShot >= PLAYER_LASER_COOLDOWN) {
        game.lasers.push(new Laser(game.rightPaddle.x, game.rightPaddle.y + game.rightPaddle.height/2, -1));
        playLaserSound();
        game.lastRightShot = currentTime;
      }
      updateAIPaddleLeft();
      if (currentTime - game.lastLeftShot >= AI_LASER_COOLDOWNS[game.aiLevel]) {
        if (game.ball.speedX < 0 && game.ball.x < WINDOW_WIDTH/2) {
          game.lasers.push(new Laser(game.leftPaddle.x + game.leftPaddle.width, game.ball.y + game.ball.size/2, 1, true));
          playLaserSound();
          game.lastLeftShot = currentTime;
        }
      }
    }
  } else {
    // Two-Player Mode Controls
    if (keysPressed["w"]) game.leftPaddle.move(true);
    if (keysPressed["s"]) game.leftPaddle.move(false);
    if (keysPressed["z"]) game.leftPaddle.activateShield();
    if (keysPressed["a"] && currentTime - game.lastLeftShot >= PLAYER_LASER_COOLDOWN) {
      game.lasers.push(new Laser(game.leftPaddle.x + game.leftPaddle.width, game.leftPaddle.y + game.leftPaddle.height/2, 1));
      playLaserSound();
      game.lastLeftShot = currentTime;
    }
    if (keysPressed["ArrowUp"]) game.rightPaddle.move(true);
    if (keysPressed["ArrowDown"]) game.rightPaddle.move(false);
    if (keysPressed["ArrowRight"]) game.rightPaddle.activateShield();
    if (keysPressed["ArrowLeft"] && currentTime - game.lastRightShot >= PLAYER_LASER_COOLDOWN) {
      game.lasers.push(new Laser(game.rightPaddle.x, game.rightPaddle.y + game.rightPaddle.height/2, -1));
      playLaserSound();
      game.lastRightShot = currentTime;
    }
  }
  
  // Deactivate shields based on controller type
  let leftShieldDuration = game.onePlayer && game.humanPlayer === "red" ? PLAYER_SHIELD_DURATION : AI_SHIELD_DURATIONS[game.aiLevel];
  let rightShieldDuration = game.onePlayer && game.humanPlayer === "blue" ? PLAYER_SHIELD_DURATION : AI_SHIELD_DURATIONS[game.aiLevel];
  if (!game.onePlayer) {
    leftShieldDuration = PLAYER_SHIELD_DURATION;
    rightShieldDuration = PLAYER_SHIELD_DURATION;
  }
  if (game.leftPaddle.shieldActive && currentTime - game.leftPaddle.shieldStartTime >= leftShieldDuration)
    game.leftPaddle.shieldActive = false;
  if (game.rightPaddle.shieldActive && currentTime - game.rightPaddle.shieldStartTime >= rightShieldDuration)
    game.rightPaddle.shieldActive = false;
  
  // Process laser collisions
  for (let i = game.lasers.length - 1; i >= 0; i--) {
    let laser = game.lasers[i];
    laser.move();
    if (laser.x < 0 || laser.x > WINDOW_WIDTH) {
      game.lasers.splice(i, 1);
      continue;
    }
    // Laser hits ball
    if (laser.x < game.ball.x + game.ball.size &&
        laser.x + laser.width > game.ball.x &&
        laser.y < game.ball.y + game.ball.size &&
        laser.y + laser.height > game.ball.y) {
      if (laser.direction > 0) {
        game.leftPaddle.score += SCORE_LASER_BALL;
      } else {
        game.rightPaddle.score += SCORE_LASER_BALL;
      }
      game.ball.explode = true;
      setTimeout(() => { game.ball.reset(); }, 200);
      game.lasers.splice(i, 1);
      continue;
    }
    // Laser hits opponent's paddle
    if (laser.direction > 0 &&
       laser.x < game.rightPaddle.x + game.rightPaddle.width &&
       laser.x + laser.width > game.rightPaddle.x &&
       laser.y < game.rightPaddle.y + game.rightPaddle.height &&
       laser.y + laser.height > game.rightPaddle.y) {
      if (!game.rightPaddle.shieldActive) {
        game.leftPaddle.score += SCORE_LASER_PADDLE;
        playHitSound();
      }
      game.lasers.splice(i, 1);
      continue;
    }
    if (laser.direction < 0 &&
       laser.x < game.leftPaddle.x + game.leftPaddle.width &&
       laser.x + laser.width > game.leftPaddle.x &&
       laser.y < game.leftPaddle.y + game.leftPaddle.height &&
       laser.y + laser.height > game.leftPaddle.y) {
      if (!game.leftPaddle.shieldActive) {
        game.rightPaddle.score += SCORE_LASER_PADDLE;
        playHitSound();
      }
      game.lasers.splice(i, 1);
      continue;
    }
  }
  
  // Move ball and check paddle collisions
  game.ball.move();
  if (game.ball.x < game.leftPaddle.x + game.leftPaddle.width &&
      game.ball.x + game.ball.size > game.leftPaddle.x &&
      game.ball.y < game.leftPaddle.y + game.leftPaddle.height &&
      game.ball.y + game.ball.size > game.leftPaddle.y &&
      game.ball.speedX < 0) {
    game.ball.speedX = Math.abs(game.ball.speedX);
    game.leftPaddle.score += SCORE_BAT_BOUNCE;
    game.ball.x = game.leftPaddle.x + game.leftPaddle.width;
    game.ball.speedY = BALL_SPEED * (Math.random() < 0.5 ? -1 : 1);
    playBounceSound();
  }
  if (game.ball.x < game.rightPaddle.x + game.rightPaddle.width &&
      game.ball.x + game.ball.size > game.rightPaddle.x &&
      game.ball.y < game.rightPaddle.y + game.rightPaddle.height &&
      game.ball.y + game.ball.size > game.rightPaddle.y &&
      game.ball.speedX > 0) {
    game.ball.speedX = -Math.abs(game.ball.speedX);
    game.rightPaddle.score += SCORE_BAT_BOUNCE;
    game.ball.x = game.rightPaddle.x - game.ball.size;
    game.ball.speedY = BALL_SPEED * (Math.random() < 0.5 ? -1 : 1);
    playBounceSound();
  }
  
  if (game.ball.x <= BORDER_WIDTH) {
    game.rightPaddle.score += SCORE_BALL_PAST;
    game.ball.reset();
  }
  if (game.ball.x + game.ball.size >= WINDOW_WIDTH - BORDER_WIDTH) {
    game.leftPaddle.score += SCORE_BALL_PAST;
    game.ball.reset();
  }
  
  // Drawing
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  drawBorder();
  game.leftPaddle.draw();
  game.rightPaddle.draw();
  game.ball.draw();
  game.lasers.forEach(laser => laser.draw());
  
  ctx.fillStyle = "white";
  ctx.font = "24px sans-serif";
  ctx.fillText("Red Score: " + game.leftPaddle.score, 50, 30);
  ctx.fillText("Blue Score: " + game.rightPaddle.score, WINDOW_WIDTH - 250, 30);
  ctx.fillText("Red Shields: " + game.leftPaddle.shieldsRemaining, 50, 60);
  ctx.fillText("Blue Shields: " + game.rightPaddle.shieldsRemaining, WINDOW_WIDTH - 250, 60);
  let timeLeft = Math.max(0, GAME_DURATION - (currentTime - game.startTime));
  ctx.fillText("Time: " + Math.ceil(timeLeft/1000), WINDOW_WIDTH/2 - 30, 30);
}

// Game Over Screen
function showGameOver() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
  ctx.fillStyle = "white";
  ctx.font = "60px sans-serif";
  let winnerText = "";
  if (game.leftPaddle.score > game.rightPaddle.score) {
    winnerText = game.onePlayer && game.humanPlayer === "red" ? "You Win!" : "Red Wins!";
  } else if (game.rightPaddle.score > game.leftPaddle.score) {
    winnerText = game.onePlayer && game.humanPlayer === "blue" ? "You Win!" : "Blue Wins!";
  } else {
    winnerText = "Tie Game!";
  }
  ctx.fillText(winnerText, (WINDOW_WIDTH - ctx.measureText(winnerText).width)/2, WINDOW_HEIGHT/2 - 60);
  
  ctx.font = "40px sans-serif";
  let scoreText = "Red: " + game.leftPaddle.score + " | Blue: " + game.rightPaddle.score;
  ctx.fillText(scoreText, (WINDOW_WIDTH - ctx.measureText(scoreText).width)/2, WINDOW_HEIGHT/2);
  
  ctx.font = "30px sans-serif";
  let instruction = "Press SPACE to restart or M for menu";
  ctx.fillText(instruction, (WINDOW_WIDTH - ctx.measureText(instruction).width)/2, WINDOW_HEIGHT/2 + 60);
}

// Main Game Loop
function gameLoop() {
  if (currentScreen === "splash") {
    showSplashScreen();
  } else if (currentScreen === "modeSelect") {
    showModeSelect();
  } else if (currentScreen === "difficultySelect") {
    showDifficultySelect();
  } else if (currentScreen === "colorSelect") {
    showColorSelect();
  } else if (currentScreen === "game") {
    if (!game.gameOver) {
      updateGame();
    } else {
      showGameOver();
    }
  }
  requestAnimationFrame(gameLoop);
}

// Input Handling
let keysPressed = {};
document.addEventListener("keydown", (e) => {
  keysPressed[e.key] = true;
  
  if (currentScreen === "splash") {
    currentScreen = "modeSelect";
  }
  else if (currentScreen === "modeSelect") {
    if (e.key === "1") {
      onePlayerMode = true;
      currentScreen = "difficultySelect";
    } else if (e.key === "2") {
      onePlayerMode = false;
      startGame();
      currentScreen = "game";
    }
  }
  else if (currentScreen === "difficultySelect") {
    if (["1", "2", "3"].includes(e.key)) {
      selectedAiLevel = parseInt(e.key);
      currentScreen = "colorSelect";
    }
  }
  else if (currentScreen === "colorSelect") {
    if (e.key === "1") {
      startGame(selectedAiLevel, "red");
      currentScreen = "game";
    } else if (e.key === "2") {
      startGame(selectedAiLevel, "blue");
      currentScreen = "game";
    }
  }
  else if (currentScreen === "game" && game.gameOver) {
    if (e.key === " ") {
      if (onePlayerMode) {
        startGame(selectedAiLevel, game.humanPlayer);
      } else {
        startGame();
      }
    } else if (e.key.toLowerCase() === "m") {
      currentScreen = "splash";
    }
  }
  else if (currentScreen === "game" && e.key.toLowerCase() === "m") {
    currentScreen = "splash";
  }
});
document.addEventListener("keyup", (e) => { keysPressed[e.key] = false; });

// Start the game loop
requestAnimationFrame(gameLoop);
</script>
</body>
</html>